# Plexus layers

## Goals

Currently, the output for plexus is quite restrictive in that you get SVG `<path>` edges and `HTMLElement` nodes, with the node layer above the edges layer, in the final graph.

The proposed changes to plexus allow greater flexibility for how graph elements are specified.

* Nodes and edges are specified as layers within the graph
* There can be any number of layers for nodes or edges
* The layers can be in any order
* Nodes and edges can be either `HTMLElement`s or `SVGElement`s
* Nodes and edges have access to the transformation state of the graph, which is to say the zoom, pan, etc.
* The `markerEnd` for `<path>` edges can now be specified
* Specifying props that do not change, per vertex or edge, is more concise

## Proposal

### Grouping components

The following two grouping components are introduced:

* `SvgScope` - This creates an `<svg>` into which nodes, edges and / or `<marker>`s can be rendered.
* `HtmlScope` - This creates a `<div>` into which nodes and / or edges can be rendered.

There can be multiple grouping components of either type within a `DirectedGraph`. For instance, the following is valid:

```jsx
<DirectedGraph>
  <HtmlScope>{/* etc... */}</HtmlScope>
  <SvgScope>{/* etc... */}</SvgScope>
  <HtmlScope>{/* etc... */}</HtmlScope>
</DirectedGraph>
```

### Layer components

The `SvgScope` and `HtmlScope` grouping components can contain any number of node or edge rendering components:

* `EdgesLayer` - Renders edges.
* `NodesLayer` - Renders nodes.
* `MeasurableNodesLayer` - Renders nodes that can be measured to determine their width and height; **this layer is required in every `DirectedGraph` and there must be only one such layer.**

The components above allow nodes and edges to be rendered. Each layer has a `render` prop that can be set to a factory function. The `render` factory function defines how each edge or vertex is rendered into a `React.ReactNode`, or omitted as `null`. The `render` prop is invoked, individually, for each edge (in `EdgesLayer`) or each vertex (in `MeasurableNodesLayer` or `NodesLayer`).

**The `MeasurableNodesLayer` is required by the `DirectedGraph`, and there can be only one of these layers.** This layer is distinct from the `NodesLayer` in that vertices are rendered by this layer, initially, without size or position information. After the first render, the nodes are measured to determine their width and height, which is then taken into consideration when generating the layout. Then, the nodes are rendered again, along any other `NodesLayer` and `EdgesLayer` that are defined, but this time size and position information is available.

The `NodesLayer` is only rendered after the size and position information for the nodes is known. In other words, the elements generated by `NodesLayer`s are not measured and are not taken into consideration when generating the layout.

The `MeasurableNodesLayer` is suitable for rendering the main visual for a node while the `NodesLayer` can be used to render decorations, such as mouse-over effects.

### SVG `<marker>`s for edge arrows

Lastly, `SvgScope`, only, can also contain:

* `ArrowMarkerDef` - These define an arrow `<marker>`, within a `<defs>` element

The `ArrowMarkerDef` is useful for defining an arrow on edge `<path>`s. See [`marker-end` on MDN](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/marker-end) for details about `marker-end` attributes.

The `ArrowMarkerDef` draws an arrow, which is intended to be used as the `markerEnd` attribute, on `<path>` edges. It can be useful to have multiple arrow markers because the marker does not inherit any styling from the path it's applied to. So, for instance, if you want to color some edges blue and others red, you will need different arrow markers for each color. If you define only one arrow marker, with the fill color as `inherit`, it will inherit the fill from the parent of the `<marker>` element, not the `<path>` it is applied to.

## Basic example

A bit of set up:

```js
function setOnNode() {
  return { style: { outline: 'inherit' } };
}
```

The existing API:

```jsx
<DirectedGraph
  minimap
  zoom
  arrowScaleDampener={0.8}
  className="DdgGraph"
  minimapClassName="u-plexusMiniMap"
  layoutManager={this.layoutManager}
  getNodeLabel={getNodeRenderer(findMatches)}
  setOnRoot={classNameIsSmall}
  setOnEdgesContainer={scaleOpacity}
  setOnNodesContainer={setOnNodesContainer}
  setOnNode={setOnNode}
  edges={edges}
  vertices={vertices}
/>
```

An equivalent graph with the proposed API:

```jsx
<DirectedGraph
  minimap
  zoom
  className="DdgGraph"
  minimapClassName="u-plexusMiniMap"
  layoutManager={this.layoutManager}
  setOnRoot={classNameIsSmall}
  edges={edges}
  vertices={vertices}
>
  <SvgScope>
    <ArrowMarkerDef scaleDampener={0.8} />
    <EdgesLayer setOnContainer={scaleOpacity} markerEnd />
  </SvgScope>
  <HtmlScope>
    <MeasurableNodesLayer
      render={getNodeRenderer(findMatches)}
      setOnContainer={setOnNodesContainer}
      style={{ outline: 'inherit' }}
    />
  </HtmlScope>
</DirectedGraph>
```

And, with annotations:

```jsx
<DirectedGraph
  // Everything still in here is unchanged
  minimap
  zoom
  className="DdgGraph"
  minimapClassName="u-plexusMiniMap"
  layoutManager={this.layoutManager}
  setOnRoot={classNameIsSmall}
  edges={edges}
  vertices={vertices}
>
  {/* Start a new <svg> in the graph */}
  <SvgScope>
    {/* Add a <def><marker>{ etc... }</marker></def> to use as a markerEnd.
        This ArrowMarkerDef uses the default local ID, which is unique within a
        `<DirectedGraph>` instance. */}
    <ArrowMarkerDef
      // The scaleDampener is an existing attribute to manage the arrow heads when scaling.
      scaleDampener={0.8}
    />
    {/* Add a `<g>` to the parent `<svg>` and render edges within it. A `render`
        prop is not specified, so the default renderer is used. */}
    <EdgesLayer
      // The `markerEnd` attribute, as an implied `true`, indicates the `markerEnd` should be
      // applied to the edges with the default local ID for `ArrowMarkerDef`s.
      markerEnd
      // `setOnContainer`, in this case, is similar to the `setOnEdgesContainer` prop from the
      // existing API.
      setOnContainer={scaleOpacity}
    />
  </SvgScope>
  {/* Start a new <div> in the graph */}
  <HtmlScope>
    {/* Add a `<div>` to the parent `<div>` and render nodes within it. As
        this is a `MeasurableNodesLayer` layer, it can render nodes a) without
        knowing the final size of the nodes or where they will eventually be
        positioned and b) the nodes in this layer can, in fact, be measured to
        establish the final width and height of the nodes. Every graph requires
        a single `MeasurableNodesLayer`. */}
    <MeasurableNodesLayer
      // More details, below, but this is very similar to the `getNodeLabel` prop
      // in the current API.
      render={getNodeRenderer(findMatches)}
      // Similar to the `setOnNodesContainer` prop in the current API. This can
      // be used to set things like className, etc., on the `<div>` wrapping
      // the nodes rendered in this layer.
      setOnContainer={setOnNodesContainer}
      // For our example graph, this extra prop replaces the `setOnNode` prop
      // from the current API. All extra props are simply passed onto the items.
      style={{ outline: 'inherit' }}
      // Alternatively, we could have used the following, which would set the
      // style as well:
      // setOnItem={setOnNode}
    />
  </HtmlScope>
</DirectedGraph>
```

## Example with multiple layers

```jsx
// Add a CSS class and use the right arrow if the edge is hovered
// or marked for emphasis
function setOnEdge(edge: TLayoutEdge, utils: TRendererUtils) {
  if (edge.uxStatus & UxStatus.Hover) {
    return {
      // this className will be merged with the className from the <EdgesLayer>
      className: 'is-hovered',
      // Override the `markerEnd` ID to show the arrow styled with
      // `.Ddg--edgeMarkerEnd is-hovered`
      markerEnd: utils.getLocalId('hoveredArrow'),
    };
  }
  if (edge.uxStatus & UxStatus.Mark) {
    return {
      // this className will be merged with the className from the <EdgesLayer>
      className: 'is-marked',
      // Override the `markerEnd` ID to show the arrow styled with
      // `.Ddg--edgeMarkerEnd is-marked`
      markerEnd: utils.getLocalId('markedArrow'),
    };
  }
  // The className will simply be what is specified on the `EdgesLayer`,
  // "DdgGraph--edge", and the markerEnd will be the default ID for
  // the markerEnd.
  return null;
}

<DirectedGraph
  className="DdgGraph"
  minimapClassName="u-plexusMiniMap"
  layoutManager={this.layoutManager}
  setOnRoot={classNameIsSmall}
  edges={edges}
  vertices={vertices}
>
  <SvgScope>
    <ArrowMarkerDef
      // Uses the default local ID for the marker end, if `markerEnd={true}`
      // is present on an `EdgesLayer`, the edge will use this marker.
      className="Ddg--edgeMarkerEnd"
      scaleDampener={0.8}
    />
    <ArrowMarkerDef
      // The localId is used to refer to this marker, later. See the call to
      // `utils.getLocalId('hoveredArrow')` in the `setOnEdge` function.
      localId="hoveredArrow"
      // The expectation here, is, the `.Ddg--edgeMarkerEnd.is-hovered` CSS
      // style has a fill color which will match the stroke of the CSS class
      // applied to hovered edges: `.DdgGraph--edge.is-hovered`.
      className="Ddg--edgeMarkerEnd is-hovered"
      scaleDampener={0.8}
    />
    <ArrowMarkerDef localId="markedArrow" className="Ddg--edgeMarkerEnd is-marked" scaleDampener={0.8} />
    <NodesLayer render={renderNodeOutline} />
    <EdgesLayer markerEnd className="DdgGraph--edge" setOnItem={setOnEdge} setOnContainer={scaleOpacity} />
    <EdgesLayer className="DdgGraph--edgePointerArea" onMouseOver={console.log} />
  </SvgScope>
  <HtmlScope>
    <MeasurableNodesLayer render={renderNode} />
  </HtmlScope>
</DirectedGraph>;
```

## API

### Graph transform data

The current state of the zoom and pan.

```jsx
type TGraphTransform = {
  k: number;
  // Graph viewport information is under consideration, but will be omitted, initially
  // vh: number;
  // vw: number;
  x: number;
  y: number;
};
```

This is available to the render functions either through a getter function, which means it can be considered when rendering the components.

#### `GraphTransformContext`

Alternatively, the current graph transform is available through the `GraphTransformContext` context. As it is through the context, it will trigger a render, for any consumers, when the transform is changed. It will always be the identity transform if zoom is not enabled.

```jsx
const graphTransformIdentity = {
  k: 1,
  // Graph viewport information is under consideration, but will be omitted, initially
  // vh: 1,
  // vw: 1,
  x: 1,
  y: 1,
};

const GraphTransformContext = React.createContext(graphTransformIdentity);
```

Consuming `GraphTransformContext` will cause a re-render when the transform changes, e.g. on zoom or pan:

```jsx
function Node(props: any) {
  return (
    <GraphTransformContext.Consumer>
      {transform => <div>The transform: {JSON.stringify(transform)}</div>}
    </GraphTransformContext.Consumer>
  );
}
```

### Render utils

```jsx
type TRendererUtils = {
  getLocalId: (idPostfix: string) => string;
  getGraphTransform: () => TGraphTransform;
};
```

`getGraphTransform` returns the _current_ graph transform. The function does not, itself, change and therefore updates to the graph's transform will not cause re-renders of the nodes (or edges).

### `TContainerPropsFactoryFn`

```jsx
type TContainerPropsFactoryInput = {
  edges: TEdge[];
  graphTransform: TGraphTransform;
  layoutEdges: TLayoutEdge[] | null;
  layoutGraph: TLayoutGraph | null;
  layoutPhase: EGraphLayoutPhase; // TODO
  layoutVertices: TLayoutVertex[] | null;
  vertices: TVertex[];
};

type TContainerPropsFactoryFn = (TContainerPropsFactoryInput) => Record<string, any> | null;
```

`TContainerPropsFactoryFn` is the type for the following props:

* `setOnRoot` prop of the `DirectedGraph` component
* `setOnContainer` prop of:
  * `HtmlScope`
  * `SvgScope`
  * `MeasurableNodesLayer`
  * `NodesLayer`
  * `EdgesLayer`

### Node renderers

```jsx
type TMeasurableNodeRenderer = (TVertex, TRendererUtils, TLayoutVertex | null) => React.ReactNode;
```

Because the `TMeasurableNodeRenderer` renders the nodes that are measured, it should always return a valid `React.ReactNode`.

Note that `TMeasurableNodeRenderer` is also passed `TLayoutVertex` as an second argument, which will have a `null` value for the initial render.

```jsx
type TNodeRenderer = (TLayoutVertex, TRendererUtils) => React.ReactNode | null;
```

`TNodeRenderer` does not receive a `TVertex` as an argument because these layers are not invoked for the initial render, and the `TLayoutVertex` is always available for these layers.

#### Example renderer

The `NodeResilientToSmallScale` example is a node that, when the graph is zoomed out and at small-scale, shows itself in a popover, on hover. The popover shows the node at full-size. When the view is not zoomed out the popover is not shown.

```jsx
const POPOVER_VISIBILITY_MAX_SCALE = 0.85;

type TProps = {
  getGraphTransform: () => TGraphTransform;
  // etc...
};

export class NodeResilientToSmallScale extends React.PureComponent<TProps> {
  state = { showPopover: false };

  onPreVisibilityChanged = visibility => {
    if (visibility) {
      const { getGraphTransform } = this.props;
      const showPopover = getGraphTransform().k < POPOVER_VISIBILITY_MAX_SCALE;
      if (showPopover !== this.state.showPopover) {
        this.setState({ showPopover });
      }
    } else {
      this.setState({ showPopover: false });
    }
  };

  render() {
    const nodeContent = <div>etc...</div>;
    return (
      <Popover onVisibleChange={this.onPreVisibilityChanged} content={nodeContent} visible={showPopover}>
        {nodeContent}
      </Popover>
    );
  }
}
// The third argument, the `TLayoutVertex` is not used by this renderer
function renderMeasurableNode(vertex: TVertex, utils: TRendererUtils) {
  return <NodeResilientToSmallScale getGraphTransform={utils.getGraphTransform} vertex={vertex} />;
}
```

### Edge renderer

```jsx
type TEdgeRenderer = (
  TLayoutEdge,
  TRendererUtils,
  props: Record<string, any> | null
) => React.ReactNode | null;
```

The built-in edge renderer, which renders a `<path>`, is likely to be sufficient for most needs as an SVG `<path>` is the pretty obvious way to render an edge, aside from WebGL or canvas, which isn't currently supported. For this reason, this renderer has not been explored very much and **the status of the `TEdgeRenderer` API is experimental**.

Note: The default edge renderer will be an export of the package. This will allow it to be wrapped by a custom edge renderer.

### `MeasurableNodesLayer` props

* `render: TMeasurableNodeRenderer`
  * Required
  * Renders a vertex into a `React.ReactNode` node for the graph. The `React.ReactNode` output by this prop is wrapped in a `<div>` when within a `HtmlScope` or `<g>` when within a `SvgScope`. See the `TMeasurableNodeRenderer` section, above, for additional details.
* `setOnContainer: TContainerPropsFactoryFn`
  * A factory function that should return an object of props to set on the wrapping container of the layer. This will be a `<div>` in a `HtmlScope` and a `<g>` in a `SvgScope`.
* `setOnItem: (TVertex, TRendererUtils, TLayoutVertex | null) => Record<string, any> | null`
  * A factory function that should return an object of props to set on the `<div>` or `<g>` which wrap the output of the `render` prop. This is invoked for each vertex, individually. If you want to set the same prop(s) on all vertices, see the `...extra` prop.
* `...extra`
  * Any additional props are added to the `<div>` or `<g>` which wrap the output of the `render` prop. For instance, if an `onClick={console.log}` prop is added to the `MeasurableNodesLayer`, it will be added to the wrapper for every node, not the container of the layer. Use the `setOnContainer` prop to add an `onClick` prop to the container `<div>`.

### `NodesLayer` props

The `NodesLayer` props are similar to the `TMeasurableNodeRenderer` props, with the two following distinctions:

* `render: TNodeRenderer`
  * Required
  * See the description for this prop in the section on `MeasurableNodesLayer` props. The difference between the two is this `render` prop is a `TNodeRenderer`.
* `setOnItem: (TLayoutVertex, TRendererUtils) => Record<string, any> | null`
  * See the description for this prop in the section on `MeasurableNodesLayer` props. The difference between the two is this `setOnItem` factory function will not receive the `TEdge` parameter.

### `EdgesLayer` props

* `render: TEdgeRenderer`
  * **Optional**
  * **Status: Experimental** - _Typically the build-in renderer is used._
  * Renders a `TLayoutEdge` into a `React.ReactNode` node for the graph. The `React.ReactNode` output by this prop is not wrapped in a container element.
* `markerEnd: boolean | string`
  * When `true`, the `markerEnd` is set to a default value, which corresponds to the default `localId` used as by the `ArrowMarkerDef` component, if a `localId` is not specified.
  * When a `string`, the `markerEnd` is set to the local ID specified by the string.
* `setOnContainer: TContainerPropsFactoryFn`
  * A factory function that should return an object of props to set on the wrapping container of the layer. This will be a `<div>` in a `HtmlScope` and a `<g>` in a `SvgScope`.
* `setOnItem: (TLayoutEdge, TRendererUtils) => Record<string, any> | null`
  * A factory function that should return an object of props to pass to the renderer prop. This is invoked for each edge, individually. The output of this function, if non-`null`, is merged with `...extra` and passed into the renderer, the value of the `render` prop. If you want to set the same prop(s) on all edges, see the `...extra` prop.
* `...extra`
  * Any additional props are merged with the output of the `setOnItem` prop, if it's defined, and passed as the third argument to the renderer.
